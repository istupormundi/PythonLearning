1. Код, отвечающий за открытие браузера стоит делать общим.
Для этого его выносим в conftest и используем как fixture для класса всего

2.Саму fixture с методом в качестве инпута можно в отдельный класс закинуть в питоновкий пакет utilities.
Типо так:
@pytest.mark.usefixtures("prepare_chrome_browser")
class BaseClass:
    pass

Затем этот BaseClass импортится и наследуется в тестовом классе.
Тогда driver будет доступен через self.driver

3. return driver сделать не получится.
Для тир дауна просто делаем в конце метода
yield
driver.close().
Но перед этим еще нужно выполнить трюк, чтобы драйвер передался дальше на тир апе:
- скормить в метод request (это как локальный инстенс)
- и ему передать значение нашего драйвера
request.cls.driver = driver

4. Запуск тестов в консоли в разных браузерах
py.test --browser_name firefox

5. чтобы запускать тесты через командную строку в разных браузерах, как в п.3,
мы должны в conftest задекларировать command line. Для этого добавляем следующий хук в conftest:
def pytest_addption(parser):
    parser.addoption(
        "--cmdopt", action="store", default="type1", help="my option: type1 or type2"
    )
cmdopt - наша команда, browser_name
acti
default - браузер по-дефолту
help - можно скипать
Дока откуда это взялось тут: https://docs.pytest.org/en/7.1.x/example/simple.html
Далее в conftest в фикче передаём значение введённого браузера в переменную:
browser_name = request.config.getoption("browser_name")
Ну и в конструкцие if else пробегаемся по браузерам и открываем нужные.

Чтобы запустить тесты в командной строчке:
- сначала через cd переходим в папку, где лежат tests,
- набираем cls
-  набираем py.test --browser_name {название браузера}.
Вариант до этой ерунды мне нравился больше (см. в папке ТЕМР)

6. Всё лишнее типо кликов, открытий страниц, ввода, ожиданий и т.д. лучше вынести в отдельный питоновский пакет PageObjects.
В тесте оставить только скелет с основными дейстивями в стиле ААА паттерна.
В тесте предлагают пейдж обжекты создавать для разных веб-страниц теста.
Пейдж обджекты должны представлять собой классы, где таплы с локаторами задаются как переменные класса,
Локальной переменной в конструкторе __init__ скармливается значение драйвера.
Поэтому дальше обращения будут в рамках этого класса как self.driver.
Ну и в классе создаются методы, которые возвращают нужный find_element(s).
При этом в последний, чтобы дессериализировать таплы, надо их передать в виде *{class_name}.{class_variable_name}

Пример:
class HomePage:
    shop = (By.LINK_TEXT, "Shop")  # tuple

    def __init__(self, driver):
        self.driver = driver


    def shop_page(self):
        return self.driver.find_element(*HomePage.shop)

7. Если у нас страницы в пейдж обджекта открываются одна за другой, то есть смысл создавать инстенся последующего класса сразу в пейдж обджекте класса, из которого их можно открыть.
Пример метода:
    def shop_page(self):
        self.driver.find_element(*HomePage.shop).click()
        checkout_page = CheckoutPage(self.driver)
        return checkout_page
 Т.е. нажали на кнопку, открывающую новую страницу,
 создали инстенс класса новой страницы,
 вернули его.
 Далее в тестах не нужно будет создавать несколько инстенсов разных классов, а только 1 хоум пейдж. Остальные будут созданы внутри пейдж обджектов.

 8. Далее выносим в бейз класс ожижидание, когда появится дропдаун.
 Нужную страну при этом передаём инпутом в метод.
 Далее в тест классе, который наследует BaseClass этот метод будет просто доступен через self.{method_name}

 9. Нужно выносить из кода захардкоженные инпуты, например, данные для логина.
 Для этого создаётся отдельный пакет с данными,
 там создаётся класс с Dictionary.
 В тестовом методе или конфтесте (если это общие данные) создаётся тест фиксча с инпутом request={data_class}.{data.var},
 в котором возвращаются request.param.
 А в методы тестов как инпуты скармливаются {fixture_method}["key_name"]

 10. Добавляем логгер в бейз класс, а потом его просто юзаем в нужных местах тестов.
 В принципе, можно копипастить всегда этот код:
    def get_logger(self):
        logger_name = inspect.stack()[1][3]
        logger = logging.getLogger(logger_name)
        formatter = logging.Formatter("%(asctime)s :%(levelname)s : %(name)s : %(message)s")
        file_handler = logging.FileHandler('pylog.txt')
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
        logger.setLevel(logging.DEBUG)

 11. Чтобы генерить хтмл рипорт с картинками мест, где фейлит, добавляем хук в конфтест
 @pytest.mark.hookwrapper
def pytest_runtest_makereport(item):
def _capture_screenshot(name):



